<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>2048</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Basic page + nav */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #faf8ef;
      color: #222;
      text-align: center;
    }
    nav {
      background: linear-gradient(90deg,#a855f7,#ec4899);
      padding: 12px;
    }
    nav a { color: white; margin: 0 12px; text-decoration: none; font-weight: 700; }

    h1 { margin: 14px 0 6px; color: #a855f7; }
    .score { margin-bottom: 12px; font-size: 18px; }

    /* Game area */
    .game-container {
      width: 420px;           /* overall size */
      max-width: 95vw;
      margin: 18px auto;
      background: #bbada0;
      border-radius: 10px;
      padding: 10px;
      box-sizing: border-box;
      position: relative;
    }

    /* Background grid */
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      padding-bottom: 0;
    }
    .cell {
      background: #cdc1b4;
      border-radius: 6px;
      min-height: 0; /* ensures proper shrinking */
      aspect-ratio: 1/1;
    }

    /* Tiles layer floating on top */
    .tiles-layer {
      position: absolute;
      top: 10px; left: 10px; right: 10px; /* match .game-container padding */
      bottom: 10px;
      pointer-events: none; /* clicks go through */
    }

    /* Tile visuals & animation */
    .tile {
      position: absolute;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: #776e65;
      transition: transform 220ms cubic-bezier(.2,.8,.2,1), background 120ms;
      will-change: transform;
      user-select: none;
      box-sizing: border-box;
    }
    .tile.pop {
      animation: pop 180ms ease;
    }
    @keyframes pop {
      0% { transform: scale(0.6); }
      60% { transform: scale(1.12); }
      100% { transform: scale(1); }
    }

    /* colors */
    .c2 { background:#eee4da; color:#776e65 }
    .c4 { background:#ede0c8; color:#776e65 }
    .c8 { background:#f2b179; color:#fff }
    .c16 { background:#f59563; color:#fff }
    .c32 { background:#f67c5f; color:#fff }
    .c64 { background:#f65e3b; color:#fff }
    .c128 { background:#edcf72; color:#fff; font-size:18px }
    .c256 { background:#edcc61; color:#fff; font-size:18px }
    .c512 { background:#edc850; color:#fff; font-size:18px }
    .c1024 { background:#edc53f; color:#fff; font-size:14px }
    .c2048 { background:#edc22e; color:#fff; font-size:14px }
    .overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); color:white; font-size:28px; border-radius:10px; visibility:hidden; }
    .overlay.show { visibility: visible; }
    .controls { margin: 10px 0; }
    .controls button { padding: 8px 14px; font-weight:700; border-radius:6px; border:none; background:#a855f7; color:white; cursor:pointer; }
  </style>
</head>
<body>
  <nav>
    <a href="../index.html">Home</a>
    <a href="../games.html">Games</a>
    <a href="../contact.html">Contact</a>
  </nav>

  <h1>2048</h1>
  <div class="score">Score: <span id="score">0</span></div>

  <div class="game-container" id="game-container">
    <div class="grid" id="grid">
      <!-- background cells -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    </div>

    <div class="tiles-layer" id="tiles-layer"></div>

    <div class="overlay" id="overlay">Game Over<br><button onclick="restartGame()" style="margin-top:12px;padding:8px 12px;border-radius:6px;border:none;background:white;color:#a855f7;font-weight:700;cursor:pointer;">Try again</button></div>
  </div>

  <div class="controls">
    <button onclick="restartGame()">New Game</button>
  </div>

  <script>
  /***** 2048 implementation with correct direction mapping + animations *****/

  const GRID = 4;
  const GAP = 10; // px, matches CSS gap
  const tilesLayer = document.getElementById('tiles-layer');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');

  let boardIds = [];      // GRID x GRID grid of tile ids or null
  let tiles = {};         // id -> {value, el}
  let nextId = 1;
  let score = 0;
  let busy = false;       // lock while animation runs

  function cellSize() {
    const w = tilesLayer.clientWidth;
    return (w - (GRID - 1) * GAP) / GRID;
  }

  function resetState() {
    boardIds = Array.from({length:GRID}, () => Array(GRID).fill(null));
    Object.keys(tiles).forEach(id => {
      try { tiles[id].el.remove(); } catch {}
    });
    tiles = {};
    nextId = 1;
    score = 0;
    scoreEl.textContent = score;
    overlay.classList.remove('show');
  }

  function spawnAt(r,c, val=null) {
    const id = String(nextId++);
    const value = val || (Math.random() < 0.9 ? 2 : 4);
    boardIds[r][c] = id;
    const el = document.createElement('div');
    el.className = 'tile c' + value;
    el.textContent = value;
    el.style.width = el.style.height = `${cellSize()}px`;
    // place initially exactly at its slot
    const x = c * (cellSize() + GAP);
    const y = r * (cellSize() + GAP);
    el.style.transform = `translate(${x}px, ${y}px)`;
    el.style.pointerEvents = 'none';
    el.classList.add('pop');
    tilesLayer.appendChild(el);
    tiles[id] = { value, el };
    // remove pop class after animation
    setTimeout(()=>el.classList.remove('pop'), 250);
  }

  function addRandomTile() {
    const empty = [];
    for (let r=0;r<GRID;r++){
      for (let c=0;c<GRID;c++){
        if (!boardIds[r][c]) empty.push([r,c]);
      }
    }
    if (empty.length === 0) return;
    const [r,c] = empty[Math.floor(Math.random()*empty.length)];
    spawnAt(r,c);
  }

  // render positions (used when resizing or initial)
  function layoutAllTiles() {
    const size = cellSize();
    for (const id in tiles) {
      const pos = findTilePosition(id);
      if (!pos) continue;
      const el = tiles[id].el;
      el.style.width = el.style.height = `${size}px`;
      const x = pos.c * (size + GAP);
      const y = pos.r * (size + GAP);
      el.style.transform = `translate(${x}px, ${y}px)`;
    }
  }

  function findTilePosition(id) {
    for (let r=0;r<GRID;r++){
      for (let c=0;c<GRID;c++){
        if (boardIds[r][c] === id) return {r,c};
      }
    }
    return null;
  }

  // slide/merge logic per line for left/up direction
  // returns { newIdsLine: [...ids or null], actions: [{type:'move'|'merge', id(s), toIndex, newValue?}] }
  function compactLine(idsLine) {
    const result = [];
    const actions = [];
    // filter non-null ids
    const items = idsLine.filter(id => id !== null);
    let i = 0, writeIndex = 0;
    while (i < items.length) {
      const id1 = items[i];
      const v1 = tiles[id1].value;
      if (i+1 < items.length) {
        const id2 = items[i+1];
        const v2 = tiles[id2].value;
        if (v1 === v2) {
          // merge id1 and id2 into id1 (reuse id1), id2 will be removed
          const newValue = v1 * 2;
          actions.push({ type:'merge', id1, id2, toIndex: writeIndex, newValue });
          result.push(id1);
          i += 2; writeIndex++;
          continue;
        }
      }
      // simple move
      actions.push({ type:'move', id: id1, toIndex: writeIndex });
      result.push(id1);
      i++; writeIndex++;
    }
    // fill with nulls to GRID length
    while (result.length < GRID) result.push(null);
    return { newIdsLine: result, actions };
  }

  // Performs a move in one of 'left','right','up','down'
  async function doMove(direction) {
    if (busy) return;
    busy = true;
    overlay.classList.remove('show');
    const prevBoard = JSON.stringify(boardIds);
    const newBoard = Array.from({length:GRID}, ()=>Array(GRID).fill(null));
    const allActions = []; // list of actions to animate & finalize
    let pointsGained = 0;

    if (direction === 'left' || direction === 'right') {
      for (let r=0;r<GRID;r++) {
        // collect ids in the order of move
        let rowIds = [];
        if (direction === 'left') {
          for (let c=0;c<GRID;c++) rowIds.push(boardIds[r][c]);
        } else {
          for (let c=GRID-1;c>=0;c--) rowIds.push(boardIds[r][c]);
        }
        const {newIdsLine, actions} = compactLine(rowIds);
        // map newIdsLine back to columns (taking reversal for right)
        for (let i=0;i<GRID;i++) {
          const id = newIdsLine[i];
          const col = (direction === 'left') ? i : (GRID-1 - i);
          newBoard[r][col] = id;
        }
        // convert actions' toIndex to final coords & collect
        for (const a of actions) {
          if (a.type === 'move') {
            const toCol = (direction === 'left') ? a.toIndex : (GRID-1 - a.toIndex);
            allActions.push({ type:'move', id: a.id, to: {r, c: toCol} });
          } else if (a.type === 'merge') {
            const toCol = (direction === 'left') ? a.toIndex : (GRID-1 - a.toIndex);
            allActions.push({ type:'merge', id1: a.id1, id2: a.id2, to: {r, c: toCol}, newValue: a.newValue });
            pointsGained += a.newValue;
          }
        }
      }
    } else if (direction === 'up' || direction === 'down') {
      for (let c=0;c<GRID;c++) {
        let colIds = [];
        if (direction === 'up') {
          for (let r=0;r<GRID;r++) colIds.push(boardIds[r][c]);
        } else {
          for (let r=GRID-1;r>=0;r--) colIds.push(boardIds[r][c]);
        }
        const {newIdsLine, actions} = compactLine(colIds);
        for (let i=0;i<GRID;i++) {
          const id = newIdsLine[i];
          const row = (direction === 'up') ? i : (GRID-1 - i);
          newBoard[row][c] = id;
        }
        for (const a of actions) {
          if (a.type === 'move') {
            const toRow = (direction === 'up') ? a.toIndex : (GRID-1 - a.toIndex);
            allActions.push({ type:'move', id: a.id, to: {r: toRow, c} });
          } else if (a.type === 'merge') {
            const toRow = (direction === 'up') ? a.toIndex : (GRID-1 - a.toIndex);
            allActions.push({ type:'merge', id1: a.id1, id2: a.id2, to: {r: toRow, c}, newValue: a.newValue });
            pointsGained += a.newValue;
          }
        }
      }
    }

    if (JSON.stringify(newBoard) === prevBoard) {
      busy = false;
      return; // no move happened
    }

    // Prepare target positions mapping for animation
    const size = cellSize();
    const targetPos = {}; // id -> {x,y}
    // for every id present in newBoard put its final coords
    for (let r=0;r<GRID;r++){
      for (let c=0;c<GRID;c++){
        const id = newBoard[r][c];
        if (id) targetPos[id] = { x: c * (size + GAP), y: r * (size + GAP) };
      }
    }
    // For merged second ids we want them to animate to same target as id1
    for (const a of allActions) {
      if (a.type === 'merge') {
        // ensure id2 has target too (it will be removed after)
        targetPos[a.id2] = { x: a.to.c * (size + GAP), y: a.to.r * (size + GAP) };
        // id1 also moves there (if not already)
        targetPos[a.id1] = { x: a.to.c * (size + GAP), y: a.to.r * (size + GAP) };
      }
    }

    // Animate all existing tiles to their target (if any)
    for (const id in tiles) {
      const el = tiles[id].el;
      if (targetPos[id]) {
        el.style.transition = 'transform 220ms cubic-bezier(.2,.8,.2,1)';
        requestAnimationFrame(()=> {
          el.style.transform = `translate(${targetPos[id].x}px, ${targetPos[id].y}px)`;
        });
      } else {
        // tile was removed (shouldn't happen normally) — animate fade then remove
        el.style.transition = 'opacity 180ms';
        el.style.opacity = '0';
      }
    }

    // Wait for the transition to finish, then finalize state
    await new Promise(res => setTimeout(res, 240));

    // Finalize merges and cleanup
    // 1) apply new values for merged id1, remove id2 elements
    for (const a of allActions) {
      if (a.type === 'merge') {
        const id1 = a.id1, id2 = a.id2;
        // update id1 value & text/background
        tiles[id1].value = a.newValue;
        const el1 = tiles[id1].el;
        el1.textContent = a.newValue;
        el1.className = 'tile c' + a.newValue + ' pop';
        // remove id2 element
        if (tiles[id2] && tiles[id2].el) {
          tiles[id2].el.remove();
          delete tiles[id2];
        }
      }
    }

    // 2) move simple moved tiles — their element already at target; update nothing else
    // 3) Update boardIds reference to newBoard
    boardIds = newBoard;

    // 4) update tiles map for values and recolor (cover simple moves)
    for (let r=0;r<GRID;r++){
      for (let c=0;c<GRID;c++){
        const id = boardIds[r][c];
        if (id && tiles[id]) {
          // ensure element matches value & color
          tiles[id].el.className = 'tile c' + tiles[id].value;
          tiles[id].el.textContent = tiles[id].value;
        }
      }
    }

    // 5) update score
    score += pointsGained;
    scoreEl.textContent = score;

    // 6) clear any lingering 'pop' class after animation
    setTimeout(() => {
      for (const id in tiles) tiles[id].el.classList.remove('pop');
    }, 260);

    // 7) spawn a random tile in the empty space
    addRandomTile();

    // 8) render small adjustments (tile sizes if resized)
    layoutAllTiles();

    // 9) check game over
    if (!hasMoves()) {
      overlay.classList.add('show');
    }

    busy = false;
  }

  function hasMoves() {
    for (let r=0;r<GRID;r++){
      for (let c=0;c<GRID;c++){
        if (!boardIds[r][c]) return true;
        const val = tiles[boardIds[r][c]].value;
        if (c < GRID-1 && boardIds[r][c+1] && tiles[boardIds[r][c+1]].value === val) return true;
        if (r < GRID-1 && boardIds[r+1][c] && tiles[boardIds[r+1][c]].value === val) return true;
      }
    }
    return false;
  }

  // PUBLIC wrappers for directions to keep mapping clear
  function moveLeft() { return doMove('left'); }
  function moveRight(){ return doMove('right'); }
  function moveUp()   { return doMove('up'); }
  function moveDown() { return doMove('down'); }

  // Input handlers
  document.addEventListener('keydown', e => {
    if (busy) return;
    if (e.key === 'ArrowLeft') moveLeft();
    else if (e.key === 'ArrowRight') moveRight();
    else if (e.key === 'ArrowUp') moveUp();
    else if (e.key === 'ArrowDown') moveDown();
  });

  let sx = 0, sy = 0;
  document.addEventListener('touchstart', e => {
    if (!e.touches || !e.touches[0]) return;
    sx = e.touches[0].clientX; sy = e.touches[0].clientY;
  }, {passive:true});
  document.addEventListener('touchend', e => {
    if (busy) return;
    if (!e.changedTouches || !e.changedTouches[0]) return;
    const dx = e.changedTouches[0].clientX - sx;
    const dy = e.changedTouches[0].clientY - sy;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 30) moveRight();
      else if (dx < -30) moveLeft();
    } else {
      if (dy > 30) moveDown();
      else if (dy < -30) moveUp();
    }
  }, {passive:true});

  // resize handling: recompute sizes and snap tiles into place
  window.addEventListener('resize', () => {
    // update tile dimensions and positions
    for (const id in tiles) {
      const el = tiles[id].el;
      el.style.width = el.style.height = `${cellSize()}px`;
    }
    layoutAllTiles();
  });

  // restart/new game
  function restartGame() {
    resetState();
    // spawn two starting tiles and build their elements
    spawnInitialTwo();
  }

  function spawnInitialTwo() {
    // spawn two tiles by placing ids into boardIds and creating elements
    const empty = [];
    for (let r=0;r<GRID;r++) for (let c=0;c<GRID;c++) empty.push([r,c]);
    // pick two distinct
    const idxA = Math.floor(Math.random()*empty.length);
    const a = empty.splice(idxA,1)[0];
    const idxB = Math.floor(Math.random()*empty.length);
    const b = empty.splice(idxB,1)[0];
    spawnAt(a[0], a[1]);
    spawnAt(b[0], b[1]);
    layoutAllTiles();
  }

  // initial game start
  function init() {
    resetState();
    spawnInitialTwo();
  }

  // expose restart to global (used by button)
  window.restartGame = restartGame;

  // start
  init();
  </script>
</body>
</html>
